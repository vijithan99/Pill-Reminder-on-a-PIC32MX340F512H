
/************************************************************************/
/*									*/
/*	oled_main.c -- Digilent board OLED Display Library Demo Program	*/
/*									*/
/************************************************************************/
/*	Author: 	Gene Apperson					*/
/*	Copyright 2011, Digilent Inc.					*/
/************************************************************************/
/*  Module Description: 						*/
/*	This provides an example of how to use the SPI-driven OLED
 * display on the ChipKit I/O board.  This code is based on code written
 * by Gene Apperson of Digilent Inc.  Part of it is from the MPIDE-
 * compatible example code and part from the MPLAB X example for the
 * stand-alone digilent OLED board.					*/
/*									*/
/************************************************************************/
/*  Revision History:                                   		*/
/*									*/
/*	07/06/2011(GeneA): created					*/
/*	October 2013: modified by James Andrew Smith			*/
/************************************************************************/


/* ------------------------------------------------------------ */
/*				Include File Definitions	*/
/* ------------------------------------------------------------ */

#include <p32xxxx.h>
#include <plib.h>
#include "OledDriver.h"
#include <inttypes.h>
#include "delay.h"
#include<assert.h>
#include<string.h>
#include <stdlib.h>
#include <stdio.h>

/* ------------------------------------------------------------ */
/*				PIC32 Configuration Settings		*/
/* ------------------------------------------------------------ */

/* Oscillator Settings
*/
#pragma config FNOSC		= PRIPLL	// Oscillator selection
#pragma config POSCMOD		= XT		// Primary oscillator mode
#pragma config FPLLIDIV 	= DIV_2		// PLL input divider
#pragma config FPLLMUL		= MUL_20	// PLL multiplier
#pragma config FPLLODIV 	= DIV_1		// PLL output divider
#pragma config FPBDIV		= DIV_1		// Peripheral bus clock divider
#pragma config FSOSCEN		= OFF		// Secondary oscillator enable

/* Clock control settings
*/
#pragma config IESO		= OFF		// Internal/external clock switchover
#pragma config FCKSM		= CSDCMD	// Clock switching (CSx)/Clock monitor (CMx)
#pragma config OSCIOFNC		= OFF		// Clock output on OSCO pin enable

/* USB Settings
*/
//#pragma config UPLLEN		= OFF		// USB PLL enable
//#pragma config UPLLIDIV	= DIV_2		// USB PLL input divider

/* Other Peripheral Device settings
*/
#pragma config FWDTEN		= OFF		// Watchdog timer enable
#pragma config WDTPS		= PS1024	// Watchdog timer postscaler

/* Code Protection settings
*/
#pragma config CP		= OFF		// Code protection
#pragma config BWP		= OFF		// Boot flash write protect
#pragma config PWP		= OFF		// Program flash write protect

/* Debug settings
*/
//#pragma config ICESEL		= ICS_PGx1	// ICE pin selection
//#pragma config DEBUG		= ON		// Debug mode select

/* ------------------------------------------------------------ */
/*				Local Type Definitions							*/
/* ------------------------------------------------------------ */

#define	fTrue	1
#define fFalse	0

#define cbPageMax	256

#define _BOARD_UC32_ 1      // this is the board we use.
#define	cntMsDelay	10000			//timer 1 delay for 1ms

#define SYS_FREQ (80000000L)
#define UART_MODULE_ID UART1
#define GetPeripheralClock() (SYS_FREQ/(1<<OSCCONbits.PBDIV))


void SendDataBuffer (const char* buffer, UINT32 size);
UINT32 GetMenuChoice (void);
UINT32 GetDataBuffer (char* buffer, UINT32 max_size);


/* ------------------------------------------------------------ */
/*				Global Variables								*/
/* ------------------------------------------------------------ */

extern BYTE	rgbOledBmp[];

BYTE rgbBmp0[] = {
	0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
	0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18
};

int testgraph[] = {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
	1, 2, 3, 4, 5, 6, 7, 8
};

BYTE rgbBmp1[32];

BYTE rgbUserFont[cbOledFontUser] = {
	0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7E,	// 0x00
	0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,	// 0x01
	0x7E, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,	// 0x02
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E,	// 0x03
	0x7E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,	// 0x04
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x7E,	// 0x05
	0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E,	// 0x06
	0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, // 0x07
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,	// 0x08
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,	// 0x09
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, // 0x0A
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, // 0x0B
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, // 0x0C
	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, // 0x0D
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,	// 0x0E
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,	// 0x0F
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// 0x10
	0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// 0x11
	0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x12
	0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, // 0x13
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, // 0x14
	0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, // 0x15
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,	// 0x16
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF	// 0x17
};

const BYTE rgbOledFont0[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		// 0x20, space
	0x00,0x00,0x00,0x5f,0x00,0x00,0x00,0x00,		// 0x21, !
	0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,		// 0x22, "
	0x64,0x3c,0x26,0x64,0x3c,0x26,0x24,0x00,		// 0x23, #
	0x26,0x49,0x49,0x7f,0x49,0x49,0x32,0x00,		// 0x23, $
	0x42,0x25,0x12,0x08,0x24,0x52,0x21,0x00,		// 0x25, %
	0x20,0x50,0x4e,0x55,0x22,0x58,0x28,0x00,		// 0x26, &
	0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,		// 0x27, '
	0x00,0x00,0x1c,0x22,0x41,0x00,0x00,0x00,		// 0x28, (
	0x00,0x00,0x00,0x41,0x22,0x1c,0x00,0x00,		// 0x29, )
	0x00,0x15,0x15,0x0e,0x0e,0x15,0x15,0x00,		// 0x2A, *
	0x00,0x08,0x08,0x3e,0x08,0x08,0x00,0x00,		// 0x2B, +
	0x00,0x00,0x00,0x50,0x30,0x00,0x00,0x00,		// 0x2C, ,
	0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,		// 0x2D, -
	0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,		// 0x2E, .
	0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00,		// 0x2F, /
	0x00,0x3e,0x41,0x41,0x41,0x3e,0x00,0x00,		// 0x30, 0
	0x00,0x00,0x41,0x7f,0x40,0x00,0x00,0x00,		// 0x31, 1
	0x00,0x42,0x61,0x51,0x49,0x6e,0x00,0x00,		// 0x32, 2
	0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00,		// 0x33, 3
	0x00,0x18,0x14,0x12,0x7f,0x10,0x00,0x00,		// 0x33, 4
	0x00,0x27,0x49,0x49,0x49,0x71,0x00,0x00,		// 0x35, 5
	0x00,0x3c,0x4a,0x49,0x48,0x70,0x00,0x00,		// 0x36, 6
	0x00,0x43,0x21,0x11,0x0d,0x03,0x00,0x00,		// 0x37, 7
	0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00,		// 0x38, 8
	0x00,0x06,0x09,0x49,0x29,0x1e,0x00,0x00,		// 0x39, 9
	0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x00,		// 0x3A, :
	0x00,0x00,0x00,0x52,0x30,0x00,0x00,0x00,		// 0x3B, //
	0x00,0x00,0x08,0x14,0x14,0x22,0x00,0x00,		// 0x3C, <
	0x00,0x14,0x14,0x14,0x14,0x14,0x14,0x00,		// 0x3D, =
	0x00,0x00,0x22,0x14,0x14,0x08,0x00,0x00,		// 0x3E, >
	0x00,0x02,0x01,0x59,0x05,0x02,0x00,0x00,		// 0x3F, ?
	0x3e,0x41,0x5d,0x55,0x4d,0x51,0x2e,0x00,		// 0x40, @
	0x40,0x7c,0x4a,0x09,0x4a,0x7c,0x40,0x00,		// 0x41, A
	0x41,0x7f,0x49,0x49,0x49,0x49,0x36,0x00,		// 0x42, B
	0x1c,0x22,0x41,0x41,0x41,0x41,0x22,0x00,		// 0x43, C
	0x41,0x7f,0x41,0x41,0x41,0x22,0x1c,0x00,		// 0x44, D
	0x41,0x7f,0x49,0x49,0x5d,0x41,0x63,0x00,		// 0x45, E
	0x41,0x7f,0x49,0x09,0x1d,0x01,0x03,0x00,		// 0x46, F
	0x1c,0x22,0x41,0x49,0x49,0x3a,0x08,0x00,		// 0x47, G
	0x41,0x7f,0x08,0x08,0x08,0x7f,0x41,0x00,		// 0x48, H
	0x00,0x41,0x41,0x7F,0x41,0x41,0x00,0x00,		// 0x49, I
	0x30,0x40,0x41,0x41,0x3F,0x01,0x01,0x00,		// 0x4A, J
	0x41,0x7f,0x08,0x0c,0x12,0x61,0x41,0x00,		// 0x4B, K
	0x41,0x7f,0x41,0x40,0x40,0x40,0x60,0x00,		// 0x4C, L
	0x41,0x7f,0x42,0x0c,0x42,0x7f,0x41,0x00,		// 0x4D, M
	0x41,0x7f,0x42,0x0c,0x11,0x7f,0x01,0x00,		// 0x4E, N
	0x1c,0x22,0x41,0x41,0x41,0x22,0x1c,0x00,		// 0x4F, O
	0x41,0x7f,0x49,0x09,0x09,0x09,0x06,0x00,		// 0x50, P
	0x0c,0x12,0x21,0x21,0x61,0x52,0x4c,0x00,		// 0x51, Q
	0x41,0x7f,0x09,0x09,0x19,0x69,0x46,0x00,		// 0x52, R
	0x66,0x49,0x49,0x49,0x49,0x49,0x33,0x00,		// 0x53, S
	0x03,0x01,0x41,0x7f,0x41,0x01,0x03,0x00,		// 0x54, T
	0x01,0x3f,0x41,0x40,0x41,0x3f,0x01,0x00,		// 0x55, U
	0x01,0x0f,0x31,0x40,0x31,0x0f,0x01,0x00,		// 0x56, V
	0x01,0x1f,0x61,0x14,0x61,0x1f,0x01,0x00,		// 0x57, W
	0x41,0x41,0x36,0x08,0x36,0x41,0x41,0x00,		// 0x58, X
	0x01,0x03,0x44,0x78,0x44,0x03,0x01,0x00,		// 0x59, Y
	0x43,0x61,0x51,0x49,0x45,0x43,0x61,0x00,		// 0x5A, Z
	0x00,0x00,0x7f,0x41,0x41,0x00,0x00,0x00,		// 0x5B, [
	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00,		// 0x5C,
	0x00,0x00,0x41,0x41,0x7f,0x00,0x00,0x00,		// 0x5D, ]
	0x00,0x04,0x02,0x01,0x01,0x02,0x04,0x00,		// 0x5E, ^
	0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,		// 0x5F, _
	0x00,0x01,0x02,0x00,0x00,0x00,0x00,0x00,		// 0x60, `
	0x00,0x34,0x4a,0x4a,0x4a,0x3c,0x40,0x00,		// 0x61, a
	0x00,0x41,0x3f,0x48,0x48,0x48,0x30,0x00,		// 0x62. b
	0x00,0x3c,0x42,0x42,0x42,0x24,0x00,0x00,		// 0x63, c
	0x00,0x30,0x48,0x48,0x49,0x3f,0x40,0x00,		// 0x63, d
	0x00,0x3c,0x4a,0x4a,0x4a,0x2c,0x00,0x00,		// 0x65, e
	0x00,0x00,0x48,0x7e,0x49,0x09,0x00,0x00,		// 0x66, f
	0x00,0x26,0x49,0x49,0x49,0x3f,0x01,0x00,		// 0x67, g
	0x41,0x7f,0x48,0x04,0x44,0x78,0x40,0x00,		// 0x68, h
	0x00,0x00,0x44,0x7d,0x40,0x00,0x00,0x00,		// 0x69, i
	0x00,0x00,0x40,0x44,0x3d,0x00,0x00,0x00,		// 0x6A, j
	0x41,0x7f,0x10,0x18,0x24,0x42,0x42,0x00,		// 0x6B, k
	0x00,0x40,0x41,0x7f,0x40,0x40,0x00,0x00,		// 0x6C, l
	0x42,0x7e,0x02,0x7c,0x02,0x7e,0x40,0x00,		// 0x6D, m
	0x42,0x7e,0x44,0x02,0x42,0x7c,0x40,0x00,		// 0x6E, n
	0x00,0x3c,0x42,0x42,0x42,0x3c,0x00,0x00,		// 0x6F, o
	0x00,0x41,0x7f,0x49,0x09,0x09,0x06,0x00,		// 0x70, p
	0x00,0x06,0x09,0x09,0x49,0x7f,0x41,0x00,		// 0x71, q
	0x00,0x42,0x7e,0x44,0x02,0x02,0x04,0x00,		// 0x72, r
	0x00,0x64,0x4a,0x4a,0x4a,0x36,0x00,0x00,		// 0x73, s
	0x00,0x04,0x3f,0x44,0x44,0x20,0x00,0x00,		// 0x73, t
	0x00,0x02,0x3e,0x40,0x40,0x22,0x7e,0x40,		// 0x75, u
	0x02,0x0e,0x32,0x40,0x32,0x0e,0x02,0x00,		// 0x76, v
	0x02,0x1e,0x62,0x18,0x62,0x1e,0x02,0x00,		// 0x77, w
	0x42,0x62,0x14,0x08,0x14,0x62,0x42,0x00,		// 0x78, x
	0x01,0x43,0x45,0x38,0x05,0x03,0x01,0x00,		// 0x79, y
	0x00,0x46,0x62,0x52,0x4a,0x46,0x62,0x00,		// 0x7A, z
	0x00,0x00,0x08,0x36,0x41,0x00,0x00,0x00,		// 0x7B, {
	0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x00,		// 0x7C, |
	0x00,0x00,0x00,0x41,0x36,0x08,0x00,0x00,		// 0x7D, }
	0x00,0x18,0x08,0x08,0x10,0x10,0x18,0x00,		// 0x7E, ~
	0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55			// 0x7F, DEL
};

/* ------------------------------------------------------------ */
/*				Local Variables									*/
/* ------------------------------------------------------------ */

BYTE rgbCmd[cbPageMax];
BYTE rgbBuf[cbPageMax];

/* ------------------------------------------------------------ */
/*				Forward Declarations							*/
/* ------------------------------------------------------------ */

void	DeviceInit();
void	AppInit();
void    StartupMenu();

/* ------------------------------------------------------------ */
/*				Procedure Definitions							*/
/* ------------------------------------------------------------ */
/***	main
**
**	Parameters:
**		none
**
**	Return Value:
**		not meaningful
**
**	Errors:
**		none
**
**	Description:
**		Top level main program entry point.  This main function calls
 *              on three functions:
 *              1. DeviceInit();     -- start up the hardware
 *              2. AppInit();        -- start up the software
 *              3. AppTask();        -- run the display.
*/

const char mainMenu[] =
{
"\n"\
"Here are the main menu choices: \r\n"\
"1. Option 1: Upload Pill Reminder \r\n"\
"2. Option 2: Pill Reminder Mode \r\n"\
"\r\n\r\nPlease Choose a Number\r\n"
};


int main(){
    SYSTEMConfigPerformance(SYS_FREQ);
    
    UINT32 menu_choice;
    UINT8 buf[1024];
    UARTConfigure(UART_MODULE_ID, UART_ENABLE_PINS_TX_RX_ONLY);
    UARTSetFifoMode(UART_MODULE_ID, UART_INTERRUPT_ON_TX_NOT_FULL | UART_INTERRUPT_ON_RX_NOT_EMPTY);
    UARTSetDataRate(UART_MODULE_ID, GetPeripheralClock(), 56700);
    UARTEnable(UART_MODULE_ID, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
    
    
    DeviceInit();
	AppInit();
    TRISE = 0x00;
    
    char time; 
    
    SendDataBuffer(mainMenu, sizeof(mainMenu));
    StartupMenu();
    
    while(1){
    menu_choice = GetMenuChoice();
    switch(menu_choice){
    case '1':
        sprintf(buf, "Please Enter Schedules:\r\n\r\n");
        SendDataBuffer(buf, strlen(buf));
        GetDataBuffer(buf, strlen(buf));
        SendDataBuffer(buf, strlen(buf));
        SendDataBuffer(mainMenu, sizeof(mainMenu));
        break;
        
    case '2':
        OledClearBuffer();
        OledSetFillPattern(OledGetStdPattern(0));
        OledSetCharUpdate(0);
        
        for(time = buf[0]-48; time>0; time--){
            OledClearBuffer();
            char v[100];
            snprintf(v, sizeof(v), "%d", time);
            OledSetCursor(7, 2);
            OledPutString(v);
            OledUpdate();
            DelayMs(10000000);
            
            if (_RD7 == 1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 1 Taken");
                OledUpdate();
                DelayMs(10000000);
                break;
            }
            else if (time ==1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 1 Missed");
                OledUpdate();
                LATE = 0xFF;
                NoPill();
                DelayMs(10000000);
            }
         }

         for(time =buf[1]-48; time>0; time--){
            OledClearBuffer();
            char v[100];
            snprintf(v, sizeof(v), "%d", time);
            OledSetCursor(7, 2);
            OledPutString(v);
            OledUpdate();
            DelayMs(10000000);
            
            if (_RD6 == 1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 2 Taken");
                OledUpdate();
                DelayMs(10000000);
                break;
            }
            else if (time==1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 2 Missed");
                OledUpdate();
                NoPill();
                DelayMs(10000000);
            }
        }

        for (time=buf[2]-48; time>0; time--){
            OledClearBuffer();
            char v[100];
            snprintf(v, sizeof(v), "%d", time);
            OledSetCursor(7, 2);
            OledPutString(v);
            OledUpdate();
            DelayMs(10000000);
            
            if (_RD5 == 1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 3 Taken");
                OledUpdate();
                DelayMs(10000000);
                break;
            }
            else if (time == 1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 3 Missed");
                OledUpdate();
                NoPill();
                DelayMs(10000000);
            }
         }


        for(time=buf[3]-48; time>0; time--){
            OledClearBuffer();
            char v[100];
            snprintf(v, sizeof(v), "%d", time);
            OledSetCursor(7, 2);
            OledPutString(v);
            OledUpdate();
            DelayMs(10000000);
            
            if (_RF1 == 1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 4 Taken");
                OledUpdate();
                DelayMs(10000000);
                break;
            }
            else if (time == 1){
                OledClearBuffer();
                OledClear();
                OledSetCursor(2, 2);
                OledPutString("Pill 4 Missed");
                OledUpdate();
                NoPill();
                DelayMs(10000000);

            }
        }
        break;
     
    default:
        StartupMenu();
        SendDataBuffer(mainMenu, sizeof(mainMenu));
        
        break;
        }
    }
}

void NoPill (){
    LATE = 0xFF;
    int count = 0;
    
    while (count < 10){
        LATE = ~LATE;
        DelayMs(2000000);
        LATE = ~LATE;
        DelayMs(2000000);
        count++;
    }
}


void StartupMenu()
{
    OledClearBuffer();
    OledClear();

    OledSetCursor(0, 0);
    OledPutString("Project Part 2");

    OledSetCursor(2, 1);
    OledPutString("1. Upload ");

    OledSetCursor(2, 2);
    OledPutString("2. Pill Remind");
    OledUpdate();
    DelayMs(2000);
}



/* ------------------------------------------------------------ */
/***	DeviceInit
**
**	Parameters:
**		none
**
**	Return Value:
**		none
**
**	Errors:
**		none
**
**	Description:
**		Perform basic hardware initialization of the board.
*/

void
DeviceInit()
	{

	DelayInit();
	OledInit();
}

/* ------------------------------------------------------------ */
/***	AppInit
**
**	Parameters:
**		none
**
**	Return Value:
**		none
**
**	Errors:
**		none
**
**	Description:
**		Initialize the application.
*/

void
AppInit()
	{
	char	ch;

	OledInit();
	OledClear();

	/* Define the user definable characters
	*/
	for (ch = 0; ch < 0x18; ch++) {
		OledDefUserChar(ch, &rgbUserFont[ch*cbOledChar]);
	}

}

/* ------------------------------------------------------------ */
/***	AppTask
**
**	Parameters:
**		none
**
**	Return Value:
**		none
**
**	Errors:
**		none
**
**	Description:
**		Perform the next iteration of the embedded application
*/


void myDelay(int amount){
    int i=0;
    while(i<amount){
        i++;
    }
}  








/***	DelayInit
**
**	Parameters:
**		none
**
**	Return Value:
**		none
**
**	Errors:
**		none
**
**	Description:
**		Initialized the hardware for use by delay functions. This
**		initializes Timer 1 to count at 10Mhz.
*/

void
DelayInit()
	{
	unsigned int tcfg;
    
	/* Configure Timer 1. This sets it up to count a 10Mhz.
	*/
	tcfg = T1_ON|T1_IDLE_CON|T1_SOURCE_INT|T1_PS_1_8|T1_GATE_OFF|T1_SYNC_EXT_OFF;
	OpenTimer1(tcfg, 0xFFFF);

}

/* ------------------------------------------------------------ */
/***	DelayMs
**
**	Parameters:
**		cms			- number of milliseconds to delay
**
**	Return Value:
**		none
**
**	Errors:
**		none
**
**	Description:
**		Delay the requested number of milliseconds. Uses Timer1.
*/

void
DelayMs(int cms)
	{
	 int j;
    for (j=0;j<cms;j++)
    {}  

}




/* ------------------------------------------------------------ */
/***	ProcName
**
**	Parameters:
**
**	Return Value:
**
**	Errors:
**
**	Description:
**
*/

/* ------------------------------------------------------------ */

/************************************************************************/
void delay(int amount)
{
    int i=0;

    while(i<(amount*100000))
    {
        i++;
    }
}

void SendDataBuffer (const char* buffer, UINT32 size){
    while(size){
        while(!UARTTransmitterIsReady(UART_MODULE_ID));
        UARTSendDataByte(UART_MODULE_ID, *buffer);
        buffer++;
        size--;
    }
    
    while(!UARTTransmissionHasCompleted(UART_MODULE_ID));
}



UINT32 GetDataBuffer(char* buffer, UINT32 max_size){
    UINT32 num_char;
    num_char=0;

    while(num_char < max_size){
        UINT8 character;
        while(!UARTReceivedDataIsAvailable(UART_MODULE_ID));
        character = UARTGetDataByte(UART_MODULE_ID);
        
        if(character=='\r')
            break;
        *buffer = character;
        buffer++;
        num_char++;
    }
    
    return num_char;
}



UINT32 GetMenuChoice (void){
    UINT32 menu_item;
    while(!UARTReceivedDataIsAvailable(UART_MODULE_ID));
    menu_item = UARTGetDataByte(UART_MODULE_ID);
    return (UINT32)menu_item;
}



